% ab-tx.tex

% !TEX program = pdflatex
\documentclass[12pt, letterpaper]{article}

\input{../preamble}

\author{Hengfeng Wei \\ hfwei@nju.edu.cn}
\title{Annotated Bibliography on Transactions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\thispagestyle{fancy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Books} \label{section:books}

\bib{\bibentry{Bernstein:Book1987}}
\note{\it
}

\bib{\bibentry{TIS:Book2001}}
\note{\it 
  It is researchers-oriented. Highly recommended.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transactional Consistency Models} \label{section:tcm}

%%%%%%%%%%%%%%%%%%%%
\subsection{Frameworks} \label{ss:framework}

\bib{\bibentry{LocksAndConsistency:BookChapter1994}}
\note{\it 
  This paper defines four degrees of consistency,
  attempting to show the equivalence of locking, dependency, and anomaly-based
  characterizations.
  The anomaly definitions were too vague.
  The authors continue to get criticism for that aspect of the definitions.
  Only the more mathematical definitions in terms of histories and dependency graphs
  or locking have stood the test of time.

  This is a book chapter version. Originally published in 1977.
  See also~\cite{Locking:VLDB1975}.
}

\bib{\bibentry{CritiqueIsolation:SIGMOD1995}}
\note{\it
  Defines Isolation Levels in terms of phenomena;
  Introduces new phenomena;
  Define Snapshot Isolation.
}

\bib{\bibentry{IsolationHistory:IST1997}}
\note{\it 
  This paper formulates these different degrees of isolation in terms of histories, 
  as in the case of the usual serialization theory 
  and proposes timestamp-based protocols for different degrees of isolation.
}

\bib{\bibentry{Adya:PhDThesis1999}}
\note{\it
  This thesis presents the first implementation-independent specifications 
  of existing ANSI isolation levels and a number of levels 
  that are widely used in commercial systems, e.g., Cursor Stability, Snapshot Isolation. 

  We use a graph-based approach to define different isolation levels 
  in a simple and intuitive manner.

  The thesis describes new implementation techniques for 
  supporting different weak consistency levels in distributed client-server environments. 
}

\bib{\bibentry{GeneralizedIsolation:ICDE2000}}
\note{\it
  Our specifications are portable; 
  they apply not only to locking implementations,
  but also to optimistic and multi-version concurrency control schemes.
  Furthermore, unlike earlier definitions, 
  our new specifications handle predicates in a correct and flexible manner at all levels.

  It also discusses ``Mixing of Isolation Levels''.
}

\bib{\bibentry{PushPull:PLDI2015}}
\note{\it
  We present a general theory of serializability, 
  unifying a wide range of transactional algorithms, 
  including some that are yet to come.
  To this end, we provide a compact semantics in which 
  concurrent transactions PUSH their effects into the shared view 
  (or UNPUSH to recall effects) 
  and PULL the effects of potentially uncommitted concurrent transactions 
  into their local view (or UNPULL to detangle).
}

\bib{\bibentry{Gotsman:CONCUR2015}}
\note{\it 
  we propose a framework for specifying a variety of consistency models for transactions 
  uniformly and declaratively. 
  Our specifications are given in the style of weak memory models,
  using structures of events and relations on them.
  The specifications are particularly concise because 
  they exploit the property of atomic visibility guaranteed by many consistency models:
  either all or none of the updates by a transaction can be visible to another one.
  This allows the specifications to abstract from individual events inside transactions.
}

\bib{\bibentry{Crooks:PODC2017}}
\note{\it 
  This paper introduces the first state-based formalization of isolation guarantees.
}

\bib{\bibentry{ClientCentric:PhDThesis2019}}
\note{\it
  The PhD Thesis version of~\cite{Crooks:PODC2017}.
}
%%%%%%%%%%%%%%%%%%%%
\subsection{Serializability} \label{ss:sr}

\bib{\bibentry{TIS:Book2001}}
\note{\it 
  The ``TIS'' book contains several variants of serializability:
  Final State Serializability, View Serializability, Conflict Serializability,
  Commit Serializability, Multiversion Serializability, Global Serializability,
  Quasi Serializability
}

\bib{\bibentry{ConsistencyAndLocking:CACM1976}}
\note{\it 
  This paper defines the concepts of transaction, consistency and schedule 
  and shows that consistency requires that a transaction 
  cannot request new locks after releasing a lock.
  Then it is argued that a transaction needs to lock a logical rather than 
  a physical subset of the database.
  These subsets may be specified by predicates.
  An implementation of predicate locks 
  which satisfies the consistency condition is suggested.

  This is the first paper to formalize mathematically the concurrency control problem.
  It also defines ``conflict serializability'', 
  which is termed DSR in~\cite{Papadimitriou:JACM1979}.
}

\bib{\bibentry{Papadimitriou:JACM1979}}
\note{\it
  It is shown that recognizing the transaction histories that are serializable
  is an NP-complete problem.
  Several efficiently recognizable subclasses are introduced.
}

\bib{\bibentry{DistributedLocking:PODS1982}}
\note{\it
  We examine the problem of determining whether a set of locked transactions, 
  accessing a distributed database, is guaranteed to produce only serializable schedules. 
  For a pair of transactions we prove that this concurrency control problem 
  (which is polynomially solvable for centralized databases) 
  is in general coNP-complete.
}

\bib{\bibentry{SerializabilityLocking:JACM1984}}
\note{\it
  It is shown that locking cannot achieve the full power of serializability.
  An exact characterization of the schedules that can be produced 
  if locking is used to control concurrency is given for two versions of serializability:
  state serializability and view serializability.

  See also its STOC conference version~\cite{SerializabilityLocking:STOC1981}.
}

\bib{\bibentry{OneCopySR:TSE1984}}
\note{\it
  Introduce One Copy Serializability (1SR), 
  as a distributed/replicated counterpart of Serializability in a single-server system.
}

\bib{\bibentry{DCC:SIAM1985}}
\note{\it 
  We present a formal framework for distributed databases, 
  and we study the complexity of the concurrency control problem in this framework.
  Our transactions are partially ordered sets of actions, 
  as opposed to the straight-line programs of the centralized case.
  The concurrency control algorithm, or scheduler, is itself a distributed program.
}

\bib{\bibentry{MVSR:PODS1985}}
\note{\it 
  In this paper we introduce a new notion of multiversion serializability (MVSR) 
  based on conflicts (MVCSR), and discuss its relation with the well known 
  single version conflict serializability (CSR). 
}

\bib{\bibentry{SSI:VLDB2012}}
\note{\it 
  This paper describes our experience implementing PostgreSQLâ€™s 
  new serializable isolation level.
  It is based on the recently-developed Serializable Snapshot Isolation (SSI) technique.
  This is the first implementation of SSI in a production database release 
  as well as the first in a database that did not previously 
  have a lock-based serializable isolation level. 
}

\bib{\bibentry{CausalSR:Raynal1996}}
\note{\it
  It defines Causal Serializability.
}
%%%%%%%%%%%%%%%%%%%%
\subsection{Snapshot Isolation} \label{ss:si}

\bib{\bibentry{CritiqueSI:EuroSys2012}}
\note{\it 
  We introduce write-snapshot isolation, a novel isolation level 
  that has a performance comparable with that of snapshot isolation, 
  and yet provides serializability. 
  The main insight in write-snapshot isolation is 
  to prevent read-write conflicts in contrast to write-write conflicts 
  that are prevented by snapshot isolation.
}

\bib{\bibentry{GSI:SRDS2005}}
\note{\it 
  It defines GSI (Generalized Snapshot Isolation) 
  and PSI (Perfix-Consistent Snapshot Isolation).

  While (conventional) snapshot isolation requires that transactions 
  observe the ``latest'' snapshot of the database, 
  generalized snapshot isolation allows the use of ``older'' snapshots,
  facilitating a replicated implementation.
}

\bib{\bibentry{ClockSI:SRDS2013}}
\note{\it 
  Clock-SI is a fully distributed protocol that implements snapshot isolation (SI) 
  for partitioned data stores.
  It derives snapshot and commit timestamps from loosely synchronized clocks,
  rather than from a centralized timestamp authority as used in current systems.
}
%%%%%%%%%%%%%%%%%%%%
\subsection{Mixed Transactional Consistency Models} \label{ss:mixed}

\bib{\bibentry{MixT:PLDI2018}}
\note{\it 
  To manipulate both weakly and strongly consistent data in a single transaction, 
  we introduce a new abstraction: mixed-consistency transactions, 
  embodied in a new embedded language, MixT.
  Programmers explicitly associate consistency models with remote storage sites;
  each atomic, isolated transaction can access a mixture of data 
  with different consistency models.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Robustness (and Dependency Graphs)} \label{section:robustness}

\bib{\bibentry{Fekete:TODS2005}}
\note{\it
  This article develops a theory that characterizes 
  when nonserializable executions of applications can occur under SI.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Concurrency Control Protocols} \label{section:cc}

%%%%%%%%%%%%%%%%%%%%
\subsection{Theory} \label{ss:theory}

\bib{\bibentry{Optimality:SIGMOD1979}}
\note{\it 
  There is a growing body of literature on various solutions 
  to the concurrency control problem. 
  This paper gives a uniform framework for evaluating these solutions, 
  and, in many cases, for establishing their optimality.
  We point out a trade-off between the performance of a scheduler 
  and the information that it uses.
  We show that most of the existing work on concurrency control 
  is concerned with specific points of this fundamental trade-off.
  For example, our framework allows us to formally show that 
  the popular approach of Serialization is the best one can hope for 
  when only syntactic information is available.
}
%%%%%%%%%%%%%%%%%%%%
\subsection{Overview} \label{ss:cc-overview}

\bib{\bibentry{CC:CSUR1981}}
\note{\it 
  In this paper we survey, consolidate, and present the state of the art 
  in distributed database concurrency control.
  The heart of our analysts is a decomposition of the concurrency control problem 
  into two major subproblems: read-write and write-write synchronization.
  We describe a series of synchronization techniques for solving each subproblem 
  and show how to combine these techniques into algorithms 
  for solving the entire concurrency control problem.
  Such algorithms are called ``concurrency control methods.''
  We describe 48 principal methods, including all practical algorithms 
  that have appeared m the literature plus several new ones.
  We concentrate on the structure and correctness of concurrency control algorithms.
  Issues of performance are given only secondary treatment.
}
%%%%%%%%%%%%%%%%%%%%
\subsection{Locking} \label{ss:locking}

\bib{\bibentry{Locking:VLDB1975}}
\note{\it 
  This paper proposes a locking protocol which associates locks with sets of resources.
  This protocol allows simultaneous locking at various granularities 
  by different transactions.
  It is based on the introduction of additional lock modes 
  besides the conventional share mode and exclusive mode.
  The protocol is generalized from simple hierarchies of locks 
  to directed acyclic graphs of locks and to dynamic graphs of locks.
  The issues of scheduling and granting conflicting requests for the same resource 
  are then discussed. 
  Lastly, these ideas are compared with the lock mechanisms 
  provided by existing data management systems.

  It introduces intention locks.
}

\bib{\bibentry{SafeLocking:JACM1982}}
\note{\it 
  Necessary and sufficient conditions are found for a locking policy to be safe,
  but it is shown that in general it is NP-complete to test for these conditions.
  However, when the database has a given structure, 
  a simple set of rules which is sufficient for safety and, moreover, 
  necessary for a wide class of natural locking policies is developed.
}

\bib{\bibentry{Beyond2PL:JACM1985}}
\note{\it
  Graph protocols.
}

\bib{\bibentry{CCLocking:CSUR1998}}
\note{\it 
  This tutorial reviews CC methods based on standard locking, 
  restart-oriented locking methods, two-phase processing methods 
  including optimistic CC, and hybrid methods 
  (combining optimistic CC and locking) in centralized systems.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formal Methods} \label{section:formal-methods}

\bib{\bibentry{ProgramLogic2PL:TR2017}}
\note{\it 
  We present a program logic for serializable transactions 
  that are able to manipulate a shared storage. 

   We show this by providing the first application of our logic 
   in terms of the Two-phase locking (2pl) protocol which ensures serializability.
}

\bib{\bibentry{AloneTogether:POPL2018}}
\note{\it 
  Unfortunately, the semantics of weak isolation is poorly understood, 
  and usually explained only informally in terms of low-level implementation artifacts.
  Consequently, verifying high-level correctness properties in such environments 
  remains a challenging problem. 
  To address this issue, we present a novel program logic 
  that enables compositional reasoning about the behavior of 
  concurrently executing weakly-isolated transactions.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Systems} \label{section:systems}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing} \label{section:testing}

\bib{\bibentry{CLOTHO:OOPSLA2019}}
\note{\it 
  This paper presents a novel testing framework for detecting serializability violations 
  in (SQL) database-backed Java applications executing on weakly-consistent storage systems.
  We manifest our approach in a tool, CLOTHO, that combines a static analyzer 
  and model checker to generate abstract executions, 
  discover serializability violations in these executions,
  and translate them back into concrete test inputs suitable for deployment 
  in a test environment.
}

\bib{\bibentry{ComplexityTx:OOPSLA2019}}
\note{\it 
  In this work, we investigate the problem of checking 
  whether a given execution of a transactional database adheres to some consistency model. 
  We show that consistency models like read committed, read atomic, and causal consistency 
  are polynomial-time checkable while prefix consistency and snapshot isolation are NP-complete in general.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{../acm-sigchi} 
\nobibliography{ab-tx}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%